{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport store from 'store';\nimport { isObject, isArray } from 'util';\nimport { Random } from 'mockjs';\nimport { getWindowWidthHeight } from '../helper';\nimport { DEFAULT_PAGE_SIZE, PARAMS_ERROR } from '../constant';\n\nrequire('@root/config');\n\nexport const globalSelf = (() => false ? window : global)();\n/**\r\n * 生成一定长度的数组\r\n * @param {number} [num=0]\r\n */\n\nexport const generateNumList = (num = 0) => [...Array(num).keys()];\n/**\r\n * 滚动到具体位置\r\n * @param {number} [scrollHeight=getWindowWidthHeight().height]\r\n */\n\nexport const scrollToFixedLocate = (scrollHeight = getWindowWidthHeight().height) => {\n  window.scrollTo({\n    top: scrollHeight,\n    behavior: 'smooth'\n  });\n};\nexport const isValidArray = data => isArray(data) && Boolean(data.length);\nexport const getStorage = (key, isDefaultEmptyObject = true) => {\n  const storeData = IS_CLIENT ? store.get(key) : {};\n  return storeData || (isDefaultEmptyObject ? {} : void 0);\n};\nexport const setStorage = (key, value, isReassign = false) => {\n  if (isObject(value)) {\n    value['timestamp'] = +new Date();\n\n    if (!isReassign) {\n      const oldStoreData = getStorage(key);\n      value = _objectSpread({}, oldStoreData, {}, value);\n    }\n  }\n\n  store.set(key, value);\n};\n\n/**\r\n * 查找集合索引\r\n * @template T\r\n * @param {TFindDataIndexProps<T>} {\r\n *   data = [],\r\n *   target,\r\n *   key,\r\n * }\r\n */\nexport const findDataIndex = ({\n  data = [],\n  target,\n  key\n}) => data.findIndex(item => Object.is(isObject(item) ? item[key] : item, target));\n/**\r\n * 获取样式\r\n * @param {*} ele\r\n * @returns {CSSStyleDeclaration}\r\n */\n\nexport const getStyle = ele => {\n  if (window.getComputedStyle) {\n    return window.getComputedStyle(ele, null);\n  }\n\n  return ele.currentStyle;\n};\n\n/**\r\n * 对数据进行分页\r\n * @param {*} [query={}]\r\n * @param {*} [data=[]]\r\n * @returns\r\n */\nexport const willDataDoPagination = ({\n  query = {},\n  data = []\n} = {}) => {\n  const {\n    pageIndex: pIndex = 1,\n    pageSize: pSize = DEFAULT_PAGE_SIZE\n  } = query;\n  const pageIndex = Math.floor(pIndex);\n  const pageSize = Math.floor(pSize);\n  const totalCount = data.length;\n  data = isArray(data) ? data : [];\n\n  try {\n    if (isNaN(pageIndex) || isNaN(pageSize)) {\n      throw new Error(PARAMS_ERROR);\n    }\n  } catch (error) {\n    return {\n      data: [],\n      totalCount,\n      pageTotal: 0,\n      pageSize: DEFAULT_PAGE_SIZE,\n      pageIndex: 1,\n      hasPrevPage: false,\n      hasNextPage: false,\n      error\n    };\n  }\n\n  let limitData = [];\n  const totalPage = Math.ceil(totalCount / pageSize);\n  const hasNextPage = pageIndex < totalPage;\n\n  if (hasNextPage || Object.is(pageIndex, totalPage)) {\n    const sliceIndex = (pageIndex - 1) * pageSize;\n    limitData = data.slice(sliceIndex, pageSize * pageIndex);\n  }\n\n  const hasLength = Boolean(totalCount);\n  return {\n    data: limitData,\n    totalCount,\n    pageTotal: totalPage,\n    pageSize: pageSize,\n    pageIndex: pageIndex,\n    hasPrevPage: hasLength && pageIndex > 1,\n    hasNextPage: hasLength && hasNextPage\n  };\n};\nexport const paginationAfterData = options => {\n  return new Promise((resolve, reject) => {\n    const info = willDataDoPagination(options);\n    return info.error ? reject(info.error) : resolve(info);\n  });\n};\nexport const createImage = (option = {}) => {\n  const {\n    width = 100,\n    height = 200,\n    bgColor = Random.color(),\n    text = Random.word(1)\n  } = option;\n  return Random.image(`${width}x${height}`, bgColor, '#fff', text);\n};","map":null,"metadata":{},"sourceType":"module"}